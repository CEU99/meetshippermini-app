import { NextRequest, NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import { getServerSupabase } from '@/lib/supabase';
import { scheduleMatch } from '@/lib/services/meeting-service';

/**
 * POST /api/matches/:id/respond
 * Accept or decline a match proposal
 */
export async function POST(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getSession();
    if (!session) {
      console.error('[API] Respond: No session found');
      return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
    }

    const { id } = await params;
    const body = await request.json();
    const { response, reason } = body;

    console.log('[API] Respond request:', {
      matchId: id,
      userFid: session.fid,
      username: session.username,
      response,
      hasReason: !!reason,
    });

    // Validate response
    if (!response || !['accept', 'decline'].includes(response)) {
      console.error('[API] Respond: Invalid response type:', response);
      return NextResponse.json(
        { error: 'Invalid response. Must be "accept" or "decline"' },
        { status: 400 }
      );
    }

    const supabase = getServerSupabase();
    const userFid = session.fid;

    // Get the match
    const { data: match, error: fetchError } = await supabase
      .from('matches')
      .select('*')
      .eq('id', id)
      .single();

    if (fetchError) {
      console.error('[API] Respond: Error fetching match:', fetchError);
      return NextResponse.json(
        { error: 'Match not found', details: fetchError.message },
        { status: 404 }
      );
    }

    if (!match) {
      console.error('[API] Respond: Match not found:', id);
      return NextResponse.json({ error: 'Match not found' }, { status: 404 });
    }

    console.log('[API] Respond: Match found:', {
      matchId: match.id,
      user_a_fid: match.user_a_fid,
      user_b_fid: match.user_b_fid,
      status: match.status,
      a_accepted: match.a_accepted,
      b_accepted: match.b_accepted,
    });

    // Check if user is a participant
    const isUserA = match.user_a_fid === userFid;
    const isUserB = match.user_b_fid === userFid;

    console.log('[API] Respond: User participation check:', {
      userFid,
      isUserA,
      isUserB,
    });

    if (!isUserA && !isUserB) {
      console.error('[API] Respond: User not a participant');
      return NextResponse.json(
        { error: 'You are not a participant in this match' },
        { status: 403 }
      );
    }

    // Check if user already responded
    if (isUserA && match.a_accepted) {
      return NextResponse.json(
        { error: 'You have already accepted this match' },
        { status: 400 }
      );
    }
    if (isUserB && match.b_accepted) {
      return NextResponse.json(
        { error: 'You have already accepted this match' },
        { status: 400 }
      );
    }

    // Check if match is still in valid state
    if (!['proposed', 'accepted_by_a', 'accepted_by_b', 'pending'].includes(match.status)) {
      return NextResponse.json(
        { error: 'This match is no longer active' },
        { status: 400 }
      );
    }

    // Prepare update
    const updateData: any = {};

    if (response === 'accept') {
      if (isUserA) {
        updateData.a_accepted = true;
      } else {
        updateData.b_accepted = true;
      }
    } else {
      // Decline
      updateData.status = 'declined';
      // Optionally store decline reason
      if (reason) {
        updateData.message = match.message
          ? `${match.message}\n\nDecline reason: ${reason}`
          : `Decline reason: ${reason}`;
      }
    }

    // Update the match
    console.log('[API] Respond: Updating match with data:', updateData);

    const { data: updatedMatch, error: updateError } = await supabase
      .from('matches')
      .update(updateData)
      .eq('id', id)
      .select()
      .single();

    if (updateError) {
      console.error('[API] Respond: Error updating match:', {
        error: updateError,
        message: updateError.message,
        details: updateError.details,
        hint: updateError.hint,
        code: updateError.code,
      });
      return NextResponse.json(
        {
          error: 'Failed to update match',
          message: updateError.message,
          details: updateError.details,
          hint: updateError.hint,
        },
        { status: 500 }
      );
    }

    if (!updatedMatch) {
      console.error('[API] Respond: Update succeeded but no data returned');
      return NextResponse.json(
        { error: 'Failed to retrieve updated match' },
        { status: 500 }
      );
    }

    console.log('[API] Respond: Match updated successfully:', {
      matchId: updatedMatch.id,
      status: updatedMatch.status,
      a_accepted: updatedMatch.a_accepted,
      b_accepted: updatedMatch.b_accepted,
    });

    // Initialize meetingLink variable for use in all code paths
    let meetingLink: string | undefined;

    // Create system messages for accept/decline
    if (response === 'decline') {
      // Notify the other user that match was declined
      const _otherUserFid = isUserA ? match.user_b_fid : match.user_a_fid;
      const declinerName = session.username || `User ${userFid}`;

      await supabase.from('messages').insert({
        match_id: id,
        sender_fid: userFid,
        content: `Match declined by ${declinerName}${reason ? `: ${reason}` : ''}`,
        is_system_message: true,
      });

      // Also notify the requester if this was a manual match
      if (match.rationale && typeof match.rationale === 'object' && 'manualMatch' in match.rationale) {
        const requesterFid = match.user_a_fid;
        if (requesterFid !== userFid) {
          await supabase.from('messages').insert({
            match_id: id,
            sender_fid: otherUserFid,
            content: `Your match request was declined.`,
            is_system_message: true,
          });
        }
      }
    } else {
      // Acceptance
      const accepterName = session.username || `User ${userFid}`;

      // If both accepted, schedule the meeting
      if (updatedMatch.a_accepted && updatedMatch.b_accepted) {
        console.log(`[Match] Both users accepted, scheduling meeting for match ${id}`);
        const scheduleResult = await scheduleMatch(id);

        if (scheduleResult.success) {
          meetingLink = scheduleResult.meetingLink;
          console.log(`[Match] Meeting scheduled: ${meetingLink}`);

          // Send system messages with meeting link to BOTH users
          // Message 1: For User A
          await supabase.from('messages').insert({
            match_id: id,
            sender_fid: match.user_a_fid,
            content: `ðŸŽ‰ Match accepted! Both parties agreed to meet. Your meeting link: ${meetingLink}`,
            is_system_message: true,
          });

          // Message 2: For User B
          await supabase.from('messages').insert({
            match_id: id,
            sender_fid: match.user_b_fid,
            content: `ðŸŽ‰ Match accepted! Both parties agreed to meet. Your meeting link: ${meetingLink}`,
            is_system_message: true,
          });
        } else {
          console.error(`[Match] Failed to schedule meeting: ${scheduleResult.error}`);

          // Send system messages about acceptance without meeting link to both users
          await supabase.from('messages').insert([
            {
              match_id: id,
              sender_fid: match.user_a_fid,
              content: `Match accepted by both parties! Meeting link generation in progress...`,
              is_system_message: true,
            },
            {
              match_id: id,
              sender_fid: match.user_b_fid,
              content: `Match accepted by both parties! Meeting link generation in progress...`,
              is_system_message: true,
            }
          ]);
        }
      } else {
        // Only one person accepted so far, notify the other
        const _otherUserFid = isUserA ? match.user_b_fid : match.user_a_fid;

        await supabase.from('messages').insert({
          match_id: id,
          sender_fid: userFid,
          content: `${accepterName} accepted the match! Waiting for your response.`,
          is_system_message: true,
        });
      }
    }

    // Fetch full match details
    const { data: matchDetails, error: detailsError } = await supabase
      .from('match_details')
      .select('*')
      .eq('id', id)
      .single();

    if (detailsError) {
      console.error('[API] Respond: Error fetching match details:', detailsError);
      // Still return success since the match was updated, just without full details
      return NextResponse.json({
        success: true,
        match: updatedMatch,
        meetingLink,
      });
    }

    console.log('[API] Respond: Request completed successfully');

    return NextResponse.json({
      success: true,
      match: matchDetails || updatedMatch,
      meetingLink,
    });
  } catch (_error) {
    console.error('[API] Respond error (uncaught):', {
      error,
      message: error instanceof Error ? error.message : 'Unknown error',
      stack: error?.stack,
    });
    return NextResponse.json(
      {
        error: 'Failed to respond to match',
        message: error instanceof Error ? error.message : 'Unknown error' || 'Unknown error occurred',
        details: error?.toString(),
      },
      { status: 500 }
    );
  }
}
